services:
  db:
    image: postgres:16
    container_name: myapp-db
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - '5433:5432' # внешний порт 5433 → внутренний 5432 (для подключения с хоста)
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres -d myapp']
      interval: 5s
      timeout: 3s
      retries: 10

  redis:
    image: redis:7
    container_name: myapp-redis
    ports:
      - "6380:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 10

  api:
    build: .
    container_name: myapp-api
    working_dir: /app
    env_file:
      - .env
    environment:
      # единое имя для вашего кода
      DATABASE_URL: postgresql+psycopg://postgres:postgres@db:5432/myapp
      # роль и редис
      APP_ROLE: api
      USE_REDIS: "1"
      REDIS_DSN: redis://redis:6379/0
      SQLALCHEMY_DISABLE_CEXT: "1"     # <<< ОБЯЗАТЕЛЬНО
      USE_UVLOOP: "0"                  # на всякий случай
    depends_on:
      db:
        condition: service_healthy
      keycloak:
        condition: service_started
      redis:
        condition: service_healthy
    ports:
      - "8000:8000"
    expose:
      - "8000"
    command: >
      uvicorn app.main:app
      --host 0.0.0.0 --port 8000
      --proxy-headers
      --workers 1
      --loop uvloop
      --http httptools
      --timeout-keep-alive 5
    volumes:
      - ./:/app
      - ./tools/websocat:/usr/local/bin/websocat:ro

  worker:
    build: .
    container_name: myapp-worker
    working_dir: /app
    restart: unless-stopped
    tty: true
    stdin_open: true
    env_file:
      - .env
    environment:
      # ── соединения БД / Redis ────────────────────────────────────────────────
      DATABASE_URL: postgresql+psycopg://postgres:postgres@db:5432/myapp
      REDIS_DSN: redis://redis:6379/0

      # ── важные флаги для устойчивости логов/цикла ────────────────────────────
      PYTHONUNBUFFERED: "1"          # мгновенная печать логов
      PYTHONFAULTHANDLER: "1"        # stack traces при крэшах
      USE_UVLOOP: "0"                # быстрее event loop, если доступен
      SQLALCHEMY_DISABLE_CEXT: "1"

      # ── параметры эмулятора (можно подстроить) ──────────────────────────────
      ROBOT_TICK_INTERVAL: "0.5"     # чем меньше, тем «плавнее» (напр. 0.25)
      POSITION_RATE_LIMIT_SEC: "0.25"
      RESCAN_COOLDOWN_SEC: "30"
      SCAN_DURATION_SEC: "6"

      # ── пул SQLAlchemy для воркера (ИМЕННО ЭТИ используются кодом) ───────────
      DB_POOL_SIZE: "40"
      DB_MAX_OVERFLOW: "80"

      # ⚠ Эти переменные в текущем коде НЕ используются (можешь удалить),
      # оставляю, чтобы не ломать окружение:
      ROBOT_POOL_SIZE: "300"
      ROBOT_MAX_OVERFLOW: "600"
      ROBOT_POOL_TIMEOUT: "30.0"
      ROBOT_CONCURRENCY: "10"

    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

    command: python -m app.workers.runner

    volumes:
      - ./:/app

    healthcheck:
      test: ["CMD", "python", "-c", "print('ok')"]
      interval: 15s
      timeout: 5s
      retries: 3
      
  scheduler:
    build: .
    container_name: myapp-scheduler
    working_dir: /app
    restart: unless-stopped
    env_file:
      - .env
    environment:
      DATABASE_URL: postgresql+psycopg://postgres:postgres@db:5432/myapp
      SQLALCHEMY_DISABLE_CEXT: "1"
      # как часто запускать джоб (секунды). По умолчанию 600 (=10 минут)
      SCHEDULER_INTERVAL_SEC: "600"
      # сколько заказывать единиц на строку отгрузки (по умолчанию 1)
      SHIPMENT_ITEM_QTY: "1"
      # суффикс имени отправки (для наглядности)
      SHIPMENT_NAME_PREFIX: "Auto shipment"
      # статус новой отправки (если у вас Enum — см. app.models.enums.ShipmentStatus)
      SHIPMENT_STATUS: "scheduled"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: python -m app.scheduler.main
    volumes:
      - ./:/app


  # --- База данных для Keycloak ---
  keycloak-db:
    image: postgres:15-alpine
    container_name: keycloak-db
    environment:
      POSTGRES_DB: keycloak_db
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: keycloak
    ports:
      - '5432:5432'
    volumes:
      - keycloak_pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U keycloak -d keycloak_db']
      interval: 5s
      timeout: 3s
      retries: 10

  # --- Keycloak ---
  keycloak:
    image: quay.io/keycloak/keycloak:26.4.0
    container_name: myapp-keycloak
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://keycloak-db:5432/keycloak_db
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloak
    depends_on:
      keycloak-db:
        condition: service_healthy
    command:
      - 'start-dev'
      - '--verbose'
      #- "--hostname=http://51.250.97.137:8080"
      - '--http-enabled=true'
      - '--proxy-headers=xforwarded'
    ports:
      - '8080:8080'

  caddy:
    image: caddy:2
    container_name: myapp-caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - api

volumes:
  pgdata:
  keycloak_pgdata:
  caddy_data:
  caddy_config: