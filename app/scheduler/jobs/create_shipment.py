# app/scheduler/jobs/create_shipment.py
from __future__ import annotations

import logging
from uuid import uuid4
from typing import List
from datetime import datetime, timezone

from sqlalchemy import select
from sqlalchemy.orm import Session

from app.scheduler.config import Config
from app.scheduler.locks import ten_minute_bucket, advisory_lock_key, acquire_lock, release_lock

from app.models.product import Product
from app.models.shipment import Shipment, ShipmentItems
from app.models.enums import ShipmentStatus

log = logging.getLogger("scheduler.job")


def now_utc() -> datetime:
    return datetime.now(timezone.utc)


def run(session: Session, cfg: Config) -> None:
    """
    1) Защита от дублей через advisory-lock + имя отправки по time-bucket
    2) Берём только товары со stock > 0
    3) Создаём Shipment и строки ShipmentItems
    4) Уменьшаем Product.stock на отгруженное количество (не уходя в минус)
    """
    ts = now_utc()
    bucket = ten_minute_bucket(ts)
    lock_key = advisory_lock_key("shipment_job_" + bucket)

    # --- 1) захватываем лок
    if not acquire_lock(session, lock_key):
        log.info("Уже выполняется на этот bucket=%s — выходим", bucket)
        return

    try:
        name = f"{cfg.shipment_name_prefix} {bucket}"

        # проверим, не создана ли уже
        existing = session.execute(
            select(Shipment).where(Shipment.name == name)
        ).scalar_one_or_none()
        if existing:
            log.info("Отправка уже есть для bucket=%s (id=%s) — пропускаем", bucket, existing.id)
            return

        # --- 2) загружаем только товары с положительным остатком
        products: List[Product] = (
            session.execute(select(Product).where(Product.stock > 0))
            .scalars()
            .all()
        )
        if not products:
            log.info("Нет товаров с положительным остатком — пропускаем")
            return

        # --- 3) создаём шапку shipment
        shipment_id = str(uuid4())
        shipment = Shipment(
            id=shipment_id,
            name=name,
            warehouse_id=None,        # при необходимости подставьте конкретный склад
            scheduled_at=ts,
            shipped_at=None,
            quantity=0,               # обновим позже
            status=cfg.shipment_status,
            customer=None,
            notes="Generated by scheduler",
        )
        session.add(shipment)
        session.flush()

        # --- 4) формируем строки и уменьшаем stock
        rows: List[ShipmentItems] = []
        total_qty = 0

        for p in products:
            # сколько хотим отгрузить
            desired = max(1, cfg.item_qty_default)
            # не уходим в минус
            ordered_qty = min(desired, max(0, p.stock))

            if ordered_qty <= 0:
                continue

            rows.append(
                ShipmentItems(
                    id=str(uuid4()),
                    shipment_id=shipment_id,
                    product_id=p.id,
                    warehouse_id=getattr(p, "warehouse_id", None),
                    ordered_quantity=ordered_qty,
                    fact_quantity=0,
                )
            )
            total_qty += ordered_qty

            # уменьшение остатка
            p.stock = p.stock - ordered_qty

        if not rows:
            log.info("Все товары имели нулевой допустимый ordered_qty — отменяем создание")
            session.rollback()
            return

        session.add_all(rows)

        # обновляем количество в шапке
        shipment.quantity = total_qty

        # коммитим транзакцию
        session.commit()

        log.info(
            "Создан shipment '%s' (id=%s) — позиций: %d, total_qty=%d",
            name, shipment_id, len(rows), total_qty
        )

    finally:
        # --- 5) освобождаем лок и фиксируем
        release_lock(session, lock_key)
        session.commit()
